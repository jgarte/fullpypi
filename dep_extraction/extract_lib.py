import ast
import os
import setuptools
import stdlib_modules_autogenerated


def get_tli(dotted_path):
    """Returns the top-level import from the full-import name."""
    if isinstance(dotted_path, type):
        return []
    if isinstance(dotted_path, tuple):
        return [tli for x in dotted_path for tli in get_tli(x)]
    return [dotted_path.split('.', 2)[0]]


def extract_tlis(root):
    """Extract the top-level import from all the imports discovered. We're
    only interested in the top-level imports because those are most
    likely to be pypi packages.
    """
    tl_imports = set(
        tli
        for path in python_files(root)
        for import_ in extract_imports(path)
        for tli in get_tli(import_)
    )

    # Also check the first-level subdirectory for packages (usually
    # ./src). Ignore more esoteric setups.
    provided = set(get_tli(x) for x in setuptools.find_packages(root))
    srcdir = os.path.join(root, './src')
    provided |= set(get_tli(x) for x in setuptools.find_packages(srcdir))
    return tl_imports, provided


def extract_imports(path):
    """Use the ast module to find everything being imported.
    """
    try:
        tree = ast.parse(open(path).read())
    except SyntaxError:
        yield SyntaxError, None

    for node in ast.walk(tree):
        if isinstance(node, ast.ImportFrom):
            if node.level > 0:
                continue
            yield node.module
        if isinstance(node, ast.Import):
            yield node.names[0].name


def python_files(root):
    """yield everything that vaguely looks like a python file in all
    subdirectories of root.
    """
    for path, _, filenames in os.walk(root):
        for x in filenames:
            if not x.endswith('.py'):
                continue
            yield os.path.join(path, x)
